/*
 * Copyright (c) 2025, WSO2 LLC. (https://www.wso2.com).
 *
 * WSO2 LLC. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package handlers

import (
"encoding/json"
"net/http"
"testing"
"time"

"github.com/stretchr/testify/assert"
"github.com/stretchr/testify/require"
"github.com/wso2/api-platform/common/constants"
commonmodels "github.com/wso2/api-platform/common/models"
api "github.com/wso2/api-platform/gateway/gateway-controller/pkg/api/generated"
"github.com/wso2/api-platform/gateway/gateway-controller/pkg/config"
"github.com/wso2/api-platform/gateway/gateway-controller/pkg/models"
"github.com/wso2/api-platform/gateway/gateway-controller/pkg/utils"
)

// Helper to create server with LLM deployment service
func createTestServerWithLLM() *APIServer {
server := createTestAPIServer()
// Create LLM deployment service with test infrastructure
llmService := utils.NewLLMDeploymentService(
server.store,
server.db,
nil, // snapshotManager
nil, // lazyResourceManager
make(map[string]*api.LLMProviderTemplate),
nil, // deploymentService
&config.RouterConfig{},
)
server.llmDeploymentService = llmService
return server
}

// TestListAPIKeysSuccess tests successful API key listing
func TestListAPIKeysSuccess(t *testing.T) {
server := createTestAPIServer()

// Create test API configuration
apiConfig := createTestStoredConfig("test-handle", "Test API", "1.0.0", "/test")
server.db.(*MockStorage).configs["test-handle"] = apiConfig
server.store.Add(apiConfig)

// Create test API keys
key1 := &models.APIKey{
ID:           "key1",
Name:         "key1",
DisplayName:  "Test Key 1",
APIKey:       "hashed-key-1",
MaskedAPIKey: "***key-1",
APIId:        "test-handle",
Status:       models.APIKeyStatusActive,
CreatedAt:    time.Now(),
CreatedBy:    "test-user",
UpdatedAt:    time.Now(),
}
key2 := &models.APIKey{
ID:           "key2",
Name:         "key2",
DisplayName:  "Test Key 2",
APIKey:       "hashed-key-2",
MaskedAPIKey: "***key-2",
APIId:        "test-handle",
Status:       models.APIKeyStatusActive,
CreatedAt:    time.Now(),
CreatedBy:    "test-user",
UpdatedAt:    time.Now(),
}

server.db.(*MockStorage).apiKeys["key1"] = key1
server.db.(*MockStorage).apiKeys["key2"] = key2

c, w := createTestContext("GET", "/apis/test-handle/api-keys", nil)
c.Set(constants.AuthContextKey, commonmodels.AuthContext{
UserID: "test-user",
Roles:  []string{"admin"},
})

server.ListAPIKeys(c, "test-handle")

assert.Equal(t, http.StatusOK, w.Code)

var response map[string]interface{}
err := json.Unmarshal(w.Body.Bytes(), &response)
require.NoError(t, err)
assert.Equal(t, "success", response["status"])
}

// TestListAPIKeysAPINotFound tests listing keys for non-existent API
func TestListAPIKeysAPINotFound(t *testing.T) {
server := createTestAPIServer()

c, w := createTestContext("GET", "/apis/nonexistent/api-keys", nil)
c.Set(constants.AuthContextKey, commonmodels.AuthContext{
UserID: "test-user",
Roles:  []string{"admin"},
})

server.ListAPIKeys(c, "nonexistent")

assert.Equal(t, http.StatusNotFound, w.Code)

var response api.ErrorResponse
err := json.Unmarshal(w.Body.Bytes(), &response)
require.NoError(t, err)
assert.Equal(t, "error", response.Status)
}

// TestListLLMProviderTemplatesEmpty tests listing with no templates
func TestListLLMProviderTemplatesEmpty(t *testing.T) {
server := createTestServerWithLLM()

c, w := createTestContext("GET", "/llm-provider-templates", nil)
server.ListLLMProviderTemplates(c, api.ListLLMProviderTemplatesParams{})

assert.Equal(t, http.StatusOK, w.Code)

var response map[string]interface{}
err := json.Unmarshal(w.Body.Bytes(), &response)
require.NoError(t, err)
assert.Equal(t, "success", response["status"])
assert.Equal(t, float64(0), response["count"])
}

// TestListLLMProviderTemplatesWithData tests listing with templates
func TestListLLMProviderTemplatesWithData(t *testing.T) {
server := createTestServerWithLLM()

now := time.Now()
template1 := &models.StoredLLMProviderTemplate{
ID: "template1",
Configuration: api.LLMProviderTemplate{
Metadata: api.Metadata{
Name: "template1",
},
Spec: api.LLMProviderTemplateData{
DisplayName: "OpenAI Template",
},
},
CreatedAt: now,
UpdatedAt: now,
}
template2 := &models.StoredLLMProviderTemplate{
ID: "template2",
Configuration: api.LLMProviderTemplate{
Metadata: api.Metadata{
Name: "template2",
},
Spec: api.LLMProviderTemplateData{
DisplayName: "Claude Template",
},
},
CreatedAt: now,
UpdatedAt: now,
}

// Add templates to store
server.store.AddTemplate(template1)
server.store.AddTemplate(template2)

c, w := createTestContext("GET", "/llm-provider-templates", nil)
server.ListLLMProviderTemplates(c, api.ListLLMProviderTemplatesParams{})

assert.Equal(t, http.StatusOK, w.Code)

var response map[string]interface{}
err := json.Unmarshal(w.Body.Bytes(), &response)
require.NoError(t, err)
assert.Equal(t, "success", response["status"])
assert.Equal(t, float64(2), response["count"])

templates := response["templates"].([]interface{})
assert.Len(t, templates, 2)
}

// TestGetLLMProviderTemplateByIdSuccess tests getting a template by ID
func TestGetLLMProviderTemplateByIdSuccess(t *testing.T) {
server := createTestServerWithLLM()

now := time.Now()
template := &models.StoredLLMProviderTemplate{
ID: "template1",
Configuration: api.LLMProviderTemplate{
Metadata: api.Metadata{
Name: "template1",
},
Spec: api.LLMProviderTemplateData{
DisplayName: "OpenAI Template",
},
},
CreatedAt: now,
UpdatedAt: now,
}

server.store.AddTemplate(template)

c, w := createTestContext("GET", "/llm-provider-templates/template1", nil)
server.GetLLMProviderTemplateById(c, "template1")

assert.Equal(t, http.StatusOK, w.Code)

var response map[string]interface{}
err := json.Unmarshal(w.Body.Bytes(), &response)
require.NoError(t, err)
assert.Equal(t, "success", response["status"])
assert.NotNil(t, response["template"])

tmpl := response["template"].(map[string]interface{})
assert.Equal(t, "template1", tmpl["id"])
}

// TestListLLMProvidersEmpty tests listing with no providers
func TestListLLMProvidersEmpty(t *testing.T) {
server := createTestServerWithLLM()

c, w := createTestContext("GET", "/llm-providers", nil)
server.ListLLMProviders(c, api.ListLLMProvidersParams{})

assert.Equal(t, http.StatusOK, w.Code)

var response map[string]interface{}
err := json.Unmarshal(w.Body.Bytes(), &response)
require.NoError(t, err)
assert.Equal(t, "success", response["status"])
assert.Equal(t, float64(0), response["count"])
}

// TestListLLMProvidersWithData tests listing with providers
func TestListLLMProvidersWithData(t *testing.T) {
server := createTestServerWithLLM()

now := time.Now()
provider := &models.StoredConfig{
ID:     "provider1",
Kind:   "LlmProvider",
Status: "active",
SourceConfiguration: map[string]interface{}{
"metadata": map[string]interface{}{
"name": "openai-provider",
},
"spec": map[string]interface{}{
"displayName": "OpenAI Provider",
"version":     "1.0.0",
"template":    "openai-template",
},
},
CreatedAt: now,
UpdatedAt: now,
}

server.store.Add(provider)

c, w := createTestContext("GET", "/llm-providers", nil)
server.ListLLMProviders(c, api.ListLLMProvidersParams{})

assert.Equal(t, http.StatusOK, w.Code)

var response map[string]interface{}
err := json.Unmarshal(w.Body.Bytes(), &response)
require.NoError(t, err)
assert.Equal(t, "success", response["status"])
assert.Equal(t, float64(1), response["count"])

providers := response["providers"].([]interface{})
assert.Len(t, providers, 1)
}

// TestListLLMProxiesEmpty tests listing with no proxies
func TestListLLMProxiesEmpty(t *testing.T) {
server := createTestServerWithLLM()

c, w := createTestContext("GET", "/llm-proxies", nil)
server.ListLLMProxies(c, api.ListLLMProxiesParams{})

assert.Equal(t, http.StatusOK, w.Code)

var response map[string]interface{}
err := json.Unmarshal(w.Body.Bytes(), &response)
require.NoError(t, err)
assert.Equal(t, "success", response["status"])
assert.Equal(t, float64(0), response["count"])
}

// TestListLLMProxiesWithData tests listing with proxies
func TestListLLMProxiesWithData(t *testing.T) {
server := createTestServerWithLLM()

now := time.Now()
proxy := &models.StoredConfig{
ID:     "proxy1",
Kind:   "LlmProxy",
Status: "active",
SourceConfiguration: map[string]interface{}{
"metadata": map[string]interface{}{
"name": "llm-proxy-1",
},
"spec": map[string]interface{}{
"displayName": "LLM Proxy 1",
"version":     "1.0.0",
"provider":    "openai-provider",
},
},
CreatedAt: now,
UpdatedAt: now,
}

server.store.Add(proxy)

c, w := createTestContext("GET", "/llm-proxies", nil)
server.ListLLMProxies(c, api.ListLLMProxiesParams{})

assert.Equal(t, http.StatusOK, w.Code)

var response map[string]interface{}
err := json.Unmarshal(w.Body.Bytes(), &response)
require.NoError(t, err)
assert.Equal(t, "success", response["status"])
assert.Equal(t, float64(1), response["count"])

proxies := response["proxies"].([]interface{})
assert.Len(t, proxies, 1)
}
